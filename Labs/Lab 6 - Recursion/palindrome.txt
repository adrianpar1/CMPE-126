We can check if an int is a palindrome with modulus and division by 10. When we divide by 10, the rightmost digit is now behind the decimal. By checking the leftmost digit as well as using modulus to check the decimal digit, we are able to recursively check the left and rightmost digits.
We can implement this by checking the base size of the integer, since we are in base 10, every digit means we can divide by an extra power of 10 to access the leftmost digit, i.e. a number with 3 digits means we divide by 10^2 to access the leftmost digit, while modulus by 10 will always give us the rightmost digit. We can then check these two values if they hold the same weight, if we do, we can now use modulus of our calculated divisor and divide by 10 to "remove" these digits, and recursively check the rest of the number to check whether it is a palindrome or not.

[HP]
The computational complexity of my code is O(N), this is due to the function requiring an operation for every digit N. While it technically requires N/2 operations, it is still reliant on how many digits the passed through value holds. For example, passing an integer with 10 digits requires the function to recursively call itself about 5 times if it were indeed a palindrome, as it would have to check the left and rightmost digit, remove these digits, then check the new value over again.